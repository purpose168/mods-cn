# 测试策略

## 文档信息

- **文档版本**: v1.0
- **创建日期**: 2026-02-13
- **最后更新**: 2026-02-13
- **维护人员**: purpose168@outlook.com

---

## 1. 概述

本文档定义了 Mods 项目的测试策略，包括单元测试、集成测试、系统测试的实施方法及测试工具使用规范。通过完善的测试体系确保代码质量和系统稳定性。

---

## 2. 测试层次

### 2.1 测试金字塔

```
                    ┌───────────┐
                    │   E2E     │  端到端测试
                    │   测试    │  (少量)
                    ├───────────┤
               ┌────┴───────────┴────┐
               │     集成测试        │  (适量)
               │                     │
               ├─────────────────────┤
          ┌────┴─────────────────────┴────┐
          │          单元测试             │  (大量)
          │                               │
          └───────────────────────────────┘
```

### 2.2 测试类型说明

| 测试类型 | 比例 | 目的 | 执行频率 |
|----------|------|------|----------|
| 单元测试 | 70% | 验证单个函数/方法 | 每次提交 |
| 集成测试 | 20% | 验证模块间交互 | 每次合并 |
| 系统测试 | 10% | 验证完整功能 | 发布前 |

---

## 3. 单元测试

### 3.1 测试原则

- **快速执行**: 单元测试应在毫秒级完成
- **独立性**: 测试之间不应有依赖
- **可重复**: 多次执行结果一致
- **自验证**: 测试结果应自动判断通过/失败

### 3.2 测试命名规范

```go
// 格式: Test<函数名>_<场景>_<预期结果>
func TestSave_NewConversation_Success(t *testing.T) {}
func TestSave_ExistingConversation_UpdatesRecord(t *testing.T) {}
func TestSave_InvalidID_ReturnsError(t *testing.T) {}
```

### 3.3 测试示例

#### 3.3.1 基本单元测试

```go
// config_test.go
package main

import (
    "testing"
    "github.com/stretchr/testify/assert"
)

func TestDefaultConfig(t *testing.T) {
    config := defaultConfig()
    
    // 验证默认值
    assert.Equal(t, "markdown", config.FormatAs)
    assert.Equal(t, 80, config.WordWrap)
    assert.NotNil(t, config.FormatText)
    assert.Contains(t, config.FormatText, "markdown")
    assert.Contains(t, config.FormatText, "json")
}

func TestConfigFormatText(t *testing.T) {
    tests := []struct {
        name     string
        format   string
        expected string
    }{
        {
            name:     "markdown format",
            format:   "markdown",
            expected: "将响应格式化为 markdown",
        },
        {
            name:     "json format",
            format:   "json",
            expected: "将响应格式化为 json",
        },
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            config := defaultConfig()
            text := config.FormatText[tt.format]
            assert.Contains(t, text, tt.expected)
        })
    }
}
```

#### 3.3.2 表格驱动测试

```go
// db_test.go
package main

import (
    "testing"
    "time"
    "github.com/stretchr/testify/assert"
    "github.com/stretchr/testify/require"
)

func TestConversationDB_Save(t *testing.T) {
    // 使用临时数据库
    db, err := openDB(t.TempDir() + "/test.db")
    require.NoError(t, err)
    defer db.Close()
    
    tests := []struct {
        name    string
        id      string
        title   string
        api     string
        model   string
        wantErr bool
    }{
        {
            name:    "valid conversation",
            id:      "abc123def456",
            title:   "Test Conversation",
            api:     "openai",
            model:   "gpt-4o",
            wantErr: false,
        },
        {
            name:    "empty title",
            id:      "def456ghi789",
            title:   "",
            api:     "openai",
            model:   "gpt-4o",
            wantErr: true,
        },
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            err := db.Save(tt.id, tt.title, tt.api, tt.model)
            if tt.wantErr {
                assert.Error(t, err)
            } else {
                assert.NoError(t, err)
                
                // 验证保存的数据
                convo, err := db.Find(tt.id)
                require.NoError(t, err)
                assert.Equal(t, tt.title, convo.Title)
                assert.Equal(t, tt.api, *convo.API)
                assert.Equal(t, tt.model, *convo.Model)
            }
        })
    }
}
```

#### 3.3.3 Mock 测试

```go
// 使用接口进行 mock
type MockStream struct {
    chunks []proto.Chunk
    index  int
    err    error
}

func (m *MockStream) Next() bool {
    m.index++
    return m.index <= len(m.chunks)
}

func (m *MockStream) Current() (proto.Chunk, error) {
    if m.err != nil {
        return proto.Chunk{}, m.err
    }
    return m.chunks[m.index-1], nil
}

func (m *MockStream) Err() error { return m.err }
func (m *MockStream) Close() error { return nil }
func (m *MockStream) Messages() []proto.Message { return nil }
func (m *MockStream) CallTools() []proto.ToolCallStatus { return nil }

func TestStreamProcessing(t *testing.T) {
    mock := &MockStream{
        chunks: []proto.Chunk{
            {Content: "Hello"},
            {Content: " World"},
        },
    }
    
    var output string
    for mock.Next() {
        chunk, err := mock.Current()
        require.NoError(t, err)
        output += chunk.Content
    }
    
    assert.Equal(t, "Hello World", output)
}
```

---

## 4. 集成测试

### 4.1 数据库集成测试

```go
// db_test.go
func TestConversationDB_Integration(t *testing.T) {
    if testing.Short() {
        t.Skip("跳过集成测试")
    }
    
    // 使用真实数据库
    db, err := openDB(t.TempDir() + "/integration.db")
    require.NoError(t, err)
    defer db.Close()
    
    // 测试完整的 CRUD 流程
    t.Run("CRUD operations", func(t *testing.T) {
        // Create
        id := "test123"
        err := db.Save(id, "Test", "openai", "gpt-4o")
        require.NoError(t, err)
        
        // Read
        convo, err := db.Find(id)
        require.NoError(t, err)
        assert.Equal(t, "Test", convo.Title)
        
        // Update
        err = db.Save(id, "Updated Test", "anthropic", "claude")
        require.NoError(t, err)
        
        convo, err = db.Find(id)
        require.NoError(t, err)
        assert.Equal(t, "Updated Test", convo.Title)
        
        // Delete
        err = db.Delete(id)
        require.NoError(t, err)
        
        _, err = db.Find(id)
        assert.Error(t, err)
    })
}
```

### 4.2 缓存集成测试

```go
// internal/cache/cache_test.go
func TestConversationCache_Integration(t *testing.T) {
    if testing.Short() {
        t.Skip("跳过集成测试")
    }
    
    cache, err := cache.NewConversations(t.TempDir())
    require.NoError(t, err)
    
    id := "test-conversation-id"
    messages := []proto.Message{
        {Role: proto.RoleUser, Content: "Hello"},
        {Role: proto.RoleAssistant, Content: "Hi there!"},
    }
    
    // Write
    err = cache.Write(id, &messages)
    require.NoError(t, err)
    
    // Read
    var loaded []proto.Message
    err = cache.Read(id, &loaded)
    require.NoError(t, err)
    assert.Len(t, loaded, 2)
    assert.Equal(t, messages[0].Content, loaded[0].Content)
    
    // Delete
    err = cache.Delete(id)
    require.NoError(t, err)
    
    // Verify deleted
    err = cache.Read(id, &loaded)
    assert.Error(t, err)
}
```

---

## 5. 系统测试

### 5.1 端到端测试

```go
// main_test.go
func TestE2E_BasicQuery(t *testing.T) {
    if testing.Short() {
        t.Skip("跳过端到端测试")
    }
    
    // 构建测试二进制
    binary := buildTestBinary(t)
    
    // 运行命令
    cmd := exec.Command(binary, "echo", "'test prompt'")
    output, err := cmd.CombinedOutput()
    
    // 验证输出
    assert.NoError(t, err)
    assert.Contains(t, string(output), "expected content")
}

func buildTestBinary(t *testing.T) string {
    binary := filepath.Join(t.TempDir(), "mods-test")
    
    cmd := exec.Command("go", "build", "-o", binary, ".")
    err := cmd.Run()
    require.NoError(t, err, "构建测试二进制失败")
    
    return binary
}
```

### 5.2 Golden 测试

```go
// internal/proto/proto_test.go
func TestStringer_Golden(t *testing.T) {
    messages := []proto.Message{
        {Role: proto.RoleSystem, Content: "System message"},
        {Role: proto.RoleUser, Content: "User message"},
        {Role: proto.RoleAssistant, Content: "Assistant response"},
    }
    
    convo := proto.Conversation(messages)
    got := convo.String()
    
    // 使用 golden 文件
    goldenFile := "testdata/TestStringer.golden"
    
    if *update {
        err := os.WriteFile(goldenFile, []byte(got), 0644)
        require.NoError(t, err)
    }
    
    want, err := os.ReadFile(goldenFile)
    require.NoError(t, err)
    assert.Equal(t, string(want), got)
}
```

---

## 6. 测试工具

### 6.1 testify 库

```go
import (
    "github.com/stretchr/testify/assert"
    "github.com/stretchr/testify/require"
    "github.com/stretchr/testify/mock"
)

// assert - 失败继续执行
assert.Equal(t, expected, actual)
assert.NoError(t, err)
assert.Contains(t, str, substr)

// require - 失败立即停止
require.NoError(t, err)
require.NotNil(t, obj)

// mock 对象
type MockRepository struct {
    mock.Mock
}

func (m *MockRepository) Find(id string) (*Conversation, error) {
    args := m.Called(id)
    return args.Get(0).(*Conversation), args.Error(1)
}
```

### 6.2 测试辅助函数

```go
// test_helpers.go
func createTempConfig(t *testing.T, content string) string {
    t.Helper()
    
    dir := t.TempDir()
    path := filepath.Join(dir, "mods.yml")
    err := os.WriteFile(path, []byte(content), 0644)
    require.NoError(t, err)
    
    return path
}

func createTempDB(t *testing.T) *convoDB {
    t.Helper()
    
    db, err := openDB(filepath.Join(t.TempDir(), "test.db"))
    require.NoError(t, err)
    
    t.Cleanup(func() {
        db.Close()
    })
    
    return db
}
```

---

## 7. 测试覆盖率

### 7.1 覆盖率目标

| 模块 | 目标覆盖率 | 当前覆盖率 |
|------|------------|------------|
| 核心模块 (mods.go) | 80% | - |
| 配置模块 (config.go) | 85% | - |
| 数据库模块 (db.go) | 90% | - |
| 缓存模块 (cache) | 85% | - |
| API 客户端 | 75% | - |
| 整体项目 | 70% | - |

### 7.2 生成覆盖率报告

```bash
# 运行测试并生成覆盖率
go test -cover ./...

# 生成详细覆盖率报告
go test -coverprofile=coverage.out ./...

# 查看覆盖率统计
go tool cover -func=coverage.out

# 生成 HTML 报告
go tool cover -html=coverage.out -o coverage.html

# 按包查看覆盖率
go test -cover -coverprofile=coverage.out ./...
go tool cover -func=coverage.out | grep total
```

### 7.3 覆盖率 CI 集成

```yaml
# .github/workflows/test.yml
- name: Run tests with coverage
  run: go test -coverprofile=coverage.out ./...
  
- name: Upload coverage
  uses: codecov/codecov-action@v3
  with:
    files: ./coverage.out
```

---

## 8. 基准测试

### 8.1 性能基准测试

```go
func BenchmarkCacheWrite(b *testing.B) {
    cache, _ := cache.NewConversations(b.TempDir())
    messages := []proto.Message{
        {Role: proto.RoleUser, Content: "Test message"},
    }
    
    b.ResetTimer()
    for i := 0; i < b.N; i++ {
        cache.Write(fmt.Sprintf("id-%d", i), &messages)
    }
}

func BenchmarkCacheRead(b *testing.B) {
    cache, _ := cache.NewConversations(b.TempDir())
    messages := []proto.Message{
        {Role: proto.RoleUser, Content: "Test message"},
    }
    cache.Write("test-id", &messages)
    
    b.ResetTimer()
    for i := 0; i < b.N; i++ {
        var loaded []proto.Message
        cache.Read("test-id", &loaded)
    }
}
```

### 8.2 运行基准测试

```bash
# 运行所有基准测试
go test -bench=. ./...

# 运行特定基准测试
go test -bench=BenchmarkCache ./internal/cache/...

# 详细内存分析
go test -bench=. -benchmem ./...

# 控制运行时间
go test -bench=. -benchtime=5s ./...
```

---

## 9. 测试最佳实践

### 9.1 测试隔离

```go
// 使用 t.TempDir() 自动清理临时目录
func TestWithTempDir(t *testing.T) {
    dir := t.TempDir() // 测试结束后自动删除
    
    // 使用 dir 进行测试
}

// 使用 t.Cleanup() 注册清理函数
func TestWithCleanup(t *testing.T) {
    db, _ := openDB("test.db")
    t.Cleanup(func() {
        db.Close()
    })
    
    // 使用 db 进行测试
}
```

### 9.2 跳过测试

```go
// 跳过短测试
func TestIntegration(t *testing.T) {
    if testing.Short() {
        t.Skip("跳过集成测试")
    }
    // 集成测试代码
}

// 条件跳过
func TestRequiresAPI(t *testing.T) {
    if os.Getenv("OPENAI_API_KEY") == "" {
        t.Skip("需要设置 OPENAI_API_KEY")
    }
    // 需要 API 的测试
}

// 运行时控制
// go test -short ./...  # 跳过集成测试
```

### 9.3 并行测试

```go
func TestParallel(t *testing.T) {
    t.Parallel() // 标记为可并行
    
    // 测试代码
}

func TestParallelSubtests(t *testing.T) {
    tests := []struct{ name string }{
        {"test1"},
        {"test2"},
    }
    
    for _, tt := range tests {
        tt := tt // 捕获变量
        t.Run(tt.name, func(t *testing.T) {
            t.Parallel()
            // 测试代码
        })
    }
}
```

---

## 10. CI/CD 测试集成

### 10.1 GitHub Actions 配置

```yaml
# .github/workflows/test.yml
name: test

on:
  push:
    branches: [main]
  pull_request:

jobs:
  test:
    strategy:
      matrix:
        go-version: ['1.24', '1.25']
        os: [ubuntu-latest, macos-latest, windows-latest]
    
    runs-on: ${{ matrix.os }}
    
    steps:
      - uses: actions/checkout@v4
      
      - uses: actions/setup-go@v5
        with:
          go-version: ${{ matrix.go-version }}
      
      - name: Download dependencies
        run: go mod download
      
      - name: Run tests
        run: go test -v -race -coverprofile=coverage.out ./...
      
      - name: Upload coverage
        uses: codecov/codecov-action@v3
        with:
          files: ./coverage.out
```

### 10.2 测试命令

```bash
# 本地运行完整测试
go test -v -race -cover ./...

# 运行特定包测试
go test -v ./internal/cache/...

# 运行特定测试
go test -v -run TestSave ./...

# 运行并生成覆盖率
go test -v -race -coverprofile=coverage.out ./...
go tool cover -html=coverage.out
```

---

## 附录

### A. 测试命令速查

| 命令 | 说明 |
|------|------|
| `go test ./...` | 运行所有测试 |
| `go test -v ./...` | 详细输出 |
| `go test -run TestName ./...` | 运行特定测试 |
| `go test -cover ./...` | 显示覆盖率 |
| `go test -race ./...` | 竞态检测 |
| `go test -short ./...` | 跳过慢测试 |
| `go test -bench=. ./...` | 运行基准测试 |
| `go test -fuzz=. ./...` | 运行模糊测试 |

### B. 相关文档

- [开发规范](../development/01-开发规范.md)
- [构建部署流程](../deployment/01-构建部署流程.md)
- [常见问题解决方案](../guides/01-常见问题解决方案.md)

### C. 外部资源

- [Go 测试指南](https://golang.org/doc/tutorial/add-a-test)
- [testify 文档](https://github.com/stretchr/testify)
- [Go 测试最佳实践](https://go.dev/doc/tutorial/add-a-test)
