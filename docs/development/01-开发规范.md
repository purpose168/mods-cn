# 开发规范

## 文档信息

- **文档版本**: v1.0
- **创建日期**: 2026-02-13
- **最后更新**: 2026-02-13
- **维护人员**: purpose168@outlook.com

---

## 1. 概述

本文档定义了 Mods 项目的开发规范，包括编码规范、命名规范、代码审查标准、文档编写规范等。所有开发人员应遵循这些规范以确保代码质量和项目一致性。

---

## 2. 编码规范

### 2.1 Go 代码规范

#### 2.1.1 基本规则

- 遵循 [Effective Go](https://golang.org/doc/effective_go) 指南
- 使用 `gofmt` 或 `goimports` 格式化代码
- 使用 `golangci-lint` 进行静态代码检查
- 所有公共函数和类型必须有文档注释

#### 2.1.2 代码格式化

```bash
# 格式化代码
go fmt ./...

# 或使用 goimports
goimports -w .
```

#### 2.1.3 注释规范

**包注释**:
```go
// Package cache 提供了一个简单的文件缓存实现。
// 支持对话缓存和临时缓存两种类型，使用 GOB 格式序列化数据。
package cache
```

**函数注释**:
```go
// Save 保存对话记录到数据库。
// 如果记录已存在则更新，否则插入新记录。
//
// 参数:
//   - id: 对话的唯一标识符（SHA-1 格式）
//   - title: 对话标题
//   - api: 使用的 API 名称
//   - model: 使用的模型名称
//
// 返回:
//   - error: 操作失败时返回错误信息
func (c *convoDB) Save(id, title, api, model string) error {
    // ...
}
```

**类型注释**:
```go
// Config 保存主配置，映射到 YAML 设置文件。
// 支持通过配置文件、环境变量和命令行参数进行配置。
type Config struct {
    // ...
}
```

### 2.2 命名规范

#### 2.2.1 包命名

- 使用简短、有意义的小写单词
- 不使用下划线或驼峰命名
- 避免使用常见名称如 `util`, `common`

```go
// 好的命名
package cache
package stream
package proto

// 不好的命名
package cacheUtil
package common_utils
```

#### 2.2.2 变量命名

- 使用驼峰命名法
- 局部变量使用简短名称
- 全局变量和导出变量使用描述性名称

```go
// 局部变量 - 简短
for i, msg := range messages {
    // ...
}

// 导出变量 - 描述性
var DefaultConfig = Config{
    // ...
}

// 布尔变量 - 使用 is/has/can 前缀
var isInputTTY bool
var hasColumn bool
```

#### 2.2.3 函数命名

- 使用驼峰命名法
- 函数名应描述其行为
- getter 函数不需要 Get 前缀

```go
// 好的命名
func (c *convoDB) Find(id string) (*Conversation, error)
func (c *convoDB) Save(id, title, api, model string) error
func isInputTTY() bool

// 不好的命名
func (c *convoDB) get_conversation(id string) (*Conversation, error)
func (c *convoDB) DoSave(id, title string) error
```

#### 2.2.4 接口命名

- 单方法接口使用 -er 后缀
- 接口名应描述其行为

```go
// 好的命名
type Stream interface {
    Next() bool
    Current() (Chunk, error)
    Err() error
    Close() error
}

type Client interface {
    Request(ctx context.Context, req Request) Stream
}

// 不好的命名
type StreamInterface interface { ... }
type IStream interface { ... }
```

#### 2.2.5 常量命名

- 使用驼峰命名法
- 导出的常量应有描述性名称

```go
// 枚举常量
const (
    RoleSystem    Role = "system"
    RoleUser      Role = "user"
    RoleAssistant Role = "assistant"
)

// 配置常量
const (
    defaultMarkdownFormatText = "将响应格式化为 markdown，不包含包围的反引号。"
    defaultJSONFormatText     = "将响应格式化为 json，不包含包围的反引号。"
)
```

### 2.3 错误处理

#### 2.3.1 错误类型定义

```go
// modsError 应用程序错误类型
type modsError struct {
    err    error  // 原始错误
    reason string // 用户友好的错误原因
}

// Error 实现 error 接口
func (e modsError) Error() string {
    if e.err != nil {
        return e.err.Error()
    }
    return e.reason
}

// Unwrap 支持错误解包
func (e modsError) Unwrap() error {
    return e.err
}
```

#### 2.3.2 错误处理模式

```go
// 好的模式 - 包装错误并添加上下文
func (c *convoDB) Save(id, title, api, model string) error {
    _, err := c.db.Exec(...)
    if err != nil {
        return fmt.Errorf("保存失败: %w", err)
    }
    return nil
}

// 好的模式 - 使用自定义错误类型
func (m *Mods) ensureKey(api API, defaultEnv, docsURL string) (string, error) {
    key := os.Getenv(defaultEnv)
    if key == "" {
        return "", modsError{
            reason: fmt.Sprintf("需要 %s", defaultEnv),
            err: newUserErrorf("您可以在 %s 获取密钥", docsURL),
        }
    }
    return key, nil
}

// 不好的模式 - 忽略错误
result, _ := someFunction()

// 不好的模式 - 直接返回底层错误
return err
```

### 2.4 并发规范

#### 2.4.1 Goroutine 使用

```go
// 使用 errgroup 管理并发
func mcpTools(ctx context.Context) (map[string][]mcp.Tool, error) {
    var wg errgroup.Group
    result := map[string][]mcp.Tool{}
    
    for name, server := range servers {
        wg.Go(func() error {
            tools, err := getTools(ctx, server)
            if err != nil {
                return err
            }
            result[name] = tools
            return nil
        })
    }
    
    return result, wg.Wait()
}
```

#### 2.4.2 同步原语

```go
// 使用互斥锁保护共享数据
type Mods struct {
    content      []string
    contentMutex *sync.Mutex
}

func (m *Mods) appendToOutput(s string) {
    m.contentMutex.Lock()
    defer m.contentMutex.Unlock()
    m.content = append(m.content, s)
}
```

---

## 3. 项目结构规范

### 3.1 目录组织

```
mods-cn/
├── main.go              # 主程序入口
├── mods.go              # 核心业务逻辑
├── config.go            # 配置管理
├── db.go                # 数据库操作
├── internal/            # 内部包（不对外暴露）
│   ├── cache/           # 缓存模块
│   ├── openai/          # OpenAI 客户端
│   ├── anthropic/       # Anthropic 客户端
│   ├── cohere/          # Cohere 客户端
│   ├── google/          # Google 客户端
│   ├── ollama/          # Ollama 客户端
│   ├── proto/           # 协议定义
│   └── stream/          # 流接口
├── docs/                # 项目文档
├── .github/             # GitHub 配置
├── go.mod               # Go 模块定义
├── go.sum               # 依赖校验
├── .golangci.yml        # Lint 配置
└── .goreleaser.yml      # 发布配置
```

### 3.2 文件命名

- 使用小写字母和下划线
- 文件名应反映其内容
- 测试文件以 `_test.go` 结尾

```
config.go          # 配置相关代码
config_test.go     # 配置测试
config_template.yml # 配置模板
```

---

## 4. 代码审查标准

### 4.1 审查清单

#### 4.1.1 功能正确性

- [ ] 代码是否实现了预期功能？
- [ ] 边界条件是否正确处理？
- [ ] 错误处理是否完善？
- [ ] 是否有潜在的内存泄漏？

#### 4.1.2 代码质量

- [ ] 代码是否易于理解？
- [ ] 命名是否清晰有意义？
- [ ] 是否有重复代码可以提取？
- [ ] 函数是否过长需要拆分？

#### 4.1.3 性能考虑

- [ ] 是否有不必要的循环或计算？
- [ ] 是否正确使用并发？
- [ ] 是否有潜在的性能瓶颈？

#### 4.1.4 安全考虑

- [ ] 是否正确处理敏感信息？
- [ ] 是否有潜在的注入风险？
- [ ] 是否正确验证输入？

### 4.2 审查流程

```
1. 提交 Pull Request
       │
       ▼
2. 自动化检查
   ├── CI 测试
   ├── Lint 检查
   └── 构建验证
       │
       ▼
3. 代码审查
   ├── 至少 1 位审查者批准
   ├── 解决所有评论
   └── 通过所有检查
       │
       ▼
4. 合并到主分支
```

---

## 5. 文档编写规范

### 5.1 文档格式

- 使用 Markdown 格式
- 文档头部包含版本和日期信息
- 使用清晰的标题层级

```markdown
# 文档标题

## 文档信息

- **文档版本**: v1.0
- **创建日期**: YYYY-MM-DD
- **最后更新**: YYYY-MM-DD
- **维护人员**: email@example.com

---

## 1. 概述

文档内容...
```

### 5.2 代码示例

- 代码示例应完整可运行
- 添加必要的注释说明
- 使用语法高亮

```go
// 示例：保存对话
func exampleSave() {
    db, err := openDB("conversations.db")
    if err != nil {
        log.Fatal(err)
    }
    defer db.Close()
    
    err = db.Save("abc123", "我的对话", "openai", "gpt-4o")
    if err != nil {
        log.Fatal(err)
    }
}
```

### 5.3 文档目录结构

```
docs/
├── architecture/        # 架构文档
│   ├── 01-项目架构概述.md
│   ├── 02-技术栈说明.md
│   └── 03-模块划分.md
├── api/                 # API 文档
│   ├── 01-API接口文档.md
│   └── 02-数据流程文档.md
├── development/         # 开发文档
│   ├── 01-开发规范.md
│   └── 02-贡献指南.md
├── deployment/          # 部署文档
│   └── 01-构建部署流程.md
├── testing/             # 测试文档
│   └── 01-测试策略.md
├── guides/              # 指南文档
│   └── 01-常见问题解决方案.md
└── README.md            # 文档索引
```

---

## 6. Git 提交规范

### 6.1 提交消息格式

```
<type>(<scope>): <subject>

<body>

<footer>
```

### 6.2 提交类型

| 类型 | 说明 |
|------|------|
| feat | 新功能 |
| fix | Bug 修复 |
| docs | 文档更新 |
| style | 代码格式（不影响功能） |
| refactor | 重构 |
| test | 测试相关 |
| chore | 构建/工具相关 |

### 6.3 提交示例

```
feat(config): 添加 MCP 服务器配置支持

- 支持 stdio、sse、http 三种 MCP 服务器类型
- 添加 MCP 工具列表和调用功能
- 更新配置模板文件

Closes #123
```

---

## 7. 测试规范

### 7.1 单元测试

```go
// config_test.go
func TestEnsureConfig(t *testing.T) {
    // 使用临时目录
    dir := t.TempDir()
    
    // 测试配置创建
    config, err := ensureConfig()
    assert.NoError(t, err)
    assert.NotNil(t, config)
}

func TestConfigDefaultValues(t *testing.T) {
    config := defaultConfig()
    
    assert.Equal(t, "markdown", config.FormatAs)
    assert.Equal(t, 80, config.WordWrap)
    assert.Equal(t, 15*time.Second, config.MCPTimeout)
}
```

### 7.2 表格驱动测试

```go
func TestResolveModel(t *testing.T) {
    tests := []struct {
        name      string
        config    Config
        wantAPI   string
        wantModel string
        wantErr   bool
    }{
        {
            name: "valid model",
            config: Config{
                API:   "openai",
                Model: "gpt-4o",
                APIs:  defaultAPIs,
            },
            wantAPI:   "openai",
            wantModel: "gpt-4o",
            wantErr:   false,
        },
        {
            name: "invalid model",
            config: Config{
                API:   "openai",
                Model: "invalid-model",
                APIs:  defaultAPIs,
            },
            wantErr: true,
        },
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            api, model, err := resolveModel(&tt.config)
            if tt.wantErr {
                assert.Error(t, err)
            } else {
                assert.NoError(t, err)
                assert.Equal(t, tt.wantAPI, api.Name)
                assert.Equal(t, tt.wantModel, model.Name)
            }
        })
    }
}
```

### 7.3 测试覆盖率

- 目标覆盖率: 70%+
- 关键模块覆盖率: 80%+

```bash
# 运行测试并生成覆盖率报告
go test -cover ./...

# 生成详细覆盖率报告
go test -coverprofile=coverage.out ./...
go tool cover -html=coverage.out
```

---

## 8. 依赖管理

### 8.1 添加依赖

```bash
# 添加新依赖
go get github.com/example/package@v1.0.0

# 整理依赖
go mod tidy

# 验证依赖
go mod verify
```

### 8.2 更新依赖

```bash
# 更新所有依赖
go get -u ./...

# 更新特定依赖
go get github.com/example/package@latest
```

### 8.3 依赖原则

- 使用稳定的版本标签
- 避免使用 `@latest` 在生产代码中
- 定期更新依赖以获取安全修复

---

## 9. Lint 配置

### 9.1 golangci.yml 配置

```yaml
# .golangci.yml
run:
  timeout: 5m
  skip-dirs:
    - docs

linters:
  enable:
    - gofmt
    - goimports
    - govet
    - errcheck
    - staticcheck
    - ineffassign
    - typecheck
    - gosimple
    - goconst
    - gocyclo
    - dupl

linters-settings:
  gocyclo:
    min-complexity: 15
  goconst:
    min-len: 3
    min-occurrences: 3

issues:
  exclude-rules:
    - path: _test\.go
      linters:
        - dupl
        - goconst
```

### 9.2 运行 Lint

```bash
# 运行所有 linter
golangci-lint run

# 运行特定 linter
golangci-lint run --disable-all --enable=errcheck

# 自动修复
golangci-lint run --fix
```

---

## 10. 开发环境设置

### 10.1 必需工具

```bash
# Go 环境
go version  # 1.24.2+

# 代码检查
go install github.com/golangci/golangci-lint/cmd/golangci-lint@latest

# 构建工具
go install github.com/goreleaser/goreleaser/v2@latest
```

### 10.2 推荐工具

```bash
# 代码格式化
go install mvdan.cc/gofumpt@latest
go install github.com/incu6us/goimports-reviser/v3@latest

# 文档工具
go install github.com/princjef/gomarkdoc/cmd/gomarkdoc@latest
```

### 10.3 IDE 配置

**VS Code**:
```json
{
    "go.useLanguageServer": true,
    "go.lintTool": "golangci-lint",
    "go.lintOnSave": "package",
    "editor.formatOnSave": true,
    "[go]": {
        "editor.defaultFormatter": "golang.go"
    }
}
```

---

## 附录

### A. 相关文档

- [构建部署流程](../deployment/01-构建部署流程.md)
- [测试策略](../testing/01-测试策略.md)
- [版本控制策略](./02-版本控制策略.md)

### B. 参考资源

- [Effective Go](https://golang.org/doc/effective_go)
- [Go Code Review Comments](https://github.com/golang/go/wiki/CodeReviewComments)
- [Uber Go Style Guide](https://github.com/uber-go/guide/blob/master/style.md)
